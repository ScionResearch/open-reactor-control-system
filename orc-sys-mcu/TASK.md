### **1. High-Level Analysis and Plan**

#### **Feature Interpretation**

The core requirement is to create a scalable and maintainable system for publishing sensor data, received from the I/O Controller via IPC, to an MQTT broker. Each sensor reading must be published to a unique MQTT topic immediately upon receipt and include a value, online status, and a precise timestamp generated by the System Controller (RP2040).

The design will be data-driven, using a central registry to map IPC message types to MQTT topics, making it simple to add or remove sensors in the future.

#### **Architectural Placement & Data Flow**

The new logic resides entirely on the **System Controller (RP2040)**, acting on data provided by the I/O Controller.

*   **System Controller (RP2040) Logic:**
    *   A new **MQTT Topic Registry** (`MqttTopicRegistry.h`) will be created to define the relationship between IPC message types and their corresponding MQTT topic strings.
    *   The **`ipcManager`** will be enhanced to register callback functions for each specific sensor message type it can receive from the I/O controller.
    *   The **`mqttManager`** will be updated with a new generic function, `publishSensorData`, which takes an IPC message, formats a JSON payload with a timestamp, and publishes it to the correct topic based on the registry.
    *   The **`timeManager`** will provide a helper function to generate ISO 8601 formatted timestamps.

*   **I/O Controller (SAMD51) Logic (Conceptual):**
    *   The I/O controller is responsible for reading its attached physical sensors (e.g., temperature, pH).
    *   Upon acquiring a new reading, it populates the corresponding data structure defined in `IPCDataStructs.h` (e.g., `TemperatureSensor`).
    *   It then sends this data structure as an IPC message to the System Controller. No changes are required to the I/O Controller's code for this feature, as this is its existing responsibility.

*   **IPC Protocol (`IPCDataStructs.h`):**
    *   No changes are required. The existing sensor data structures and message type enums are sufficient.

*   **New Data Flow (Mermaid Diagram):**

    ```mermaid
    sequenceDiagram
        participant I/O Controller (SAMD51)
        participant RP2040 IPC Layer
        participant RP2040 ipcManager
        participant RP2040 mqttManager
        participant MQTT Broker

        I/O Controller (SAMD51)->>+RP2040 IPC Layer: Sends IPC Message (e.g., TemperatureSensor data)
        RP2040 IPC Layer->>+RP2040 ipcManager: Dispatches to registered callback (handleTemperatureData)
        RP2040 ipcManager->>+RP2040 mqttManager: Calls publishSensorData(msg)
        RP2040 mqttManager->>RP2040 mqttManager: Gets current time (ISO 8601)
        RP2040 mqttManager->>RP2040 mqttManager: Looks up topic in MqttTopicRegistry
        RP2040 mqttManager->>RP2040 mqttManager: Creates JSON payload: {"value": ..., "online": ..., "timestamp": "..."}
        RP2040 mqttManager->>+MQTT Broker: Publishes JSON to topic (e.g., orcs/sensors/temperature/0)
        MQTT Broker-->>-RP2040 mqttManager: (ACK)
        deactivate RP2040 IPC Layer
        deactivate RP2040 ipcManager
        deactivate RP2040 mqttManager
    ```

#### **Impact Summary**

*   `src/network/mqttManager.h`: **Modified** to add the new `publishSensorData` prototype.
*   `src/network/mqttManager.cpp`: **Modified** to implement the dynamic publishing logic.
*   `src/utils/ipcManager.h`: **Modified** to add a prototype for registering callbacks.
*   `src/utils/ipcManager.cpp`: **Modified** to implement callback registration and the handler functions.
*   `src/sys_init.cpp`: **Modified** to call the new callback registration function during initialization.
*   `src/utils/timeManager.cpp`: **Modified** to add a timestamp formatting helper.
*   `src/utils/timeManager.h`: **Modified** to add the new helper prototype.
*   `src/utils/terminalManager.cpp`: **Modified** to add test commands for simulating IPC messages.
*   `src/network/MqttTopicRegistry.h`: **New File** to define the topic mappings.

---

### **2. Complete Implementation & Code Generation**

#### **Backend (C++)**

##### **1. Create New File: `src/network/MqttTopicRegistry.h`**

This file provides a single place to manage the mapping of IPC messages to MQTT topics, making future additions easy.

```cpp
// src/network/MqttTopicRegistry.h
#pragma once

#include "lib/IPCprotocol/IPCDataStructs.h"
#include <map>

// A map to associate IPC message IDs with their corresponding MQTT topic strings.
// The object ID from the IPC message will be appended to the topic.
// e.g., for MSG_TEMPERATURE_SENSOR with objId 0, the topic will be "orcs/sensors/temperature/0"
const std::map<MessageTypes, const char*> MqttTopicRegistry = {
    {MSG_POWER_SENSOR, "orcs/sensors/power"},
    {MSG_TEMPERATURE_SENSOR, "orcs/sensors/temperature"},
    {MSG_PH_SENSOR, "orcs/sensors/ph"},
    {MSG_DO_SENSOR, "orcs/sensors/do"},
    {MSG_OD_SENSOR, "orcs/sensors/od"},
    {MSG_GAS_FLOW_SENSOR, "orcs/sensors/gasflow"},
    {MSG_PRESSURE_SENSOR, "orcs/sensors/pressure"},
    {MSG_STIRRER_SPEED_SENSOR, "orcs/sensors/stirrer"},
    {MSG_WEIGHT_SENSOR, "orcs/sensors/weight"}
};
```

##### **2. Modify `src/utils/timeManager.h`**

Add the prototype for the new timestamp helper function.

```cpp
// src/utils/timeManager.h
#pragma once

#include "../sys_init.h"

void init_timeManager(void);
void manageTime(void);
bool updateGlobalDateTime(const DateTime &dt);
bool getGlobalDateTime(DateTime &dt, uint32_t timeout = 1000);
String getISO8601Timestamp(uint32_t timeout = 100); // <-- ADD THIS LINE

extern MCP79410 rtc;

// Global DateTime protection
extern volatile bool dateTimeLocked;
extern DateTime globalDateTime;

// Update timing
#define TIME_UPDATE_INTERVAL 1000
```

##### **3. Modify `src/utils/timeManager.cpp`**

Add the implementation for the timestamp helper function.

```cpp
// src/utils/timeManager.cpp
// ... (existing code) ...

// ADD THIS NEW FUNCTION AT THE END OF THE FILE
/**
 * @brief Gets the current time as a thread-safe, ISO 8601 formatted string.
 * @param timeout Milliseconds to wait for the time lock.
 * @return A string in "YYYY-MM-DDTHH:MM:SSZ" format, or an empty string on timeout.
 */
String getISO8601Timestamp(uint32_t timeout) {
    DateTime now;
    if (getGlobalDateTime(now, timeout)) {
        char buf[21]; // YYYY-MM-DDTHH:MM:SSZ + null
        snprintf(buf, sizeof(buf), "%04d-%02d-%02dT%02d:%02d:%02dZ",
                 now.year, now.month, now.day, now.hour, now.minute, now.second);
        return String(buf);
    }
    return "";
}
```

##### **4. Modify `src/network/mqttManager.h`**

Update the header with the new generic publishing function. We will keep `mqttPublishSensorData` as it publishes the summary status, and add a new function for granular, event-driven sensor data.

```cpp
// src/network/mqttManager.h
#pragma once

#include "../sys_init.h"
#include <PubSubClient.h>

#define MQTT_PUBLISH_INTERVAL 10000 // Publish data every 10 seconds
#define MQTT_RECONNECT_INTERVAL 5000 // Attempt to reconnect every 5 seconds

void init_mqttManager();
void manageMqtt();
void mqttPublishAllSensorData(); // This is the old summary publisher
void publishSensorData(const Message& msg); // <-- ADD THIS NEW FUNCTION

extern PubSubClient mqttClient;
```

##### **5. Modify `src/network/mqttManager.cpp`**

Implement the new publishing logic. This replaces the old `mqttPublishAllSensorData` which is no longer suitable.

```cpp
// src/network/mqttManager.cpp
#include "mqttManager.h"
#include "network.h"
#include "../utils/statusManager.h"
#include "../utils/timeManager.h"
#include "../utils/logger.h"
#include "MqttTopicRegistry.h" // <-- INCLUDE THE NEW REGISTRY

WiFiClient mqttNetClient;
PubSubClient mqttClient(mqttNetClient);

unsigned long lastMqttReconnectAttempt = 0;
unsigned long lastMqttPublishTime = 0; // This can now be used for the summary status publish

// ... (init_mqttManager, reconnect, and manageMqtt functions remain largely the same)
// ... The original mqttPublishAllSensorData which reads from the 'status' struct can remain for system health topics.

/**
 * @brief Publishes a single sensor reading received from the I/O controller.
 *
 * This function is called by IPC callbacks. It decodes the IPC message,
 * constructs a JSON payload, and publishes it to the appropriate MQTT topic.
 *
 * @param msg The IPC message containing the sensor data.
 */
void publishSensorData(const Message& msg) {
    if (!mqttClient.connected()) {
        return;
    }

    // 1. Find the base topic from the registry
    auto it = MqttTopicRegistry.find((MessageTypes)msg.msgId);
    if (it == MqttTopicRegistry.end()) {
        log(LOG_WARNING, false, "MQTT: No topic registered for MSG ID %d\n", msg.msgId);
        return;
    }
    
    // 2. Construct the full topic with object ID
    char fullTopic[128];
    snprintf(fullTopic, sizeof(fullTopic), "%s/%d", it->second, msg.objId);

    // 3. Get a timestamp
    String timestamp = getISO8601Timestamp();
    if (timestamp.length() == 0) {
        log(LOG_WARNING, true, "MQTT: Could not get timestamp for publishing.\n");
        return; // Can't publish without a timestamp
    }

    // 4. Create JSON payload based on message type
    StaticJsonDocument<256> doc;
    doc["timestamp"] = timestamp;

    // Decode the data payload based on the message type
    switch (msg.msgId) {
        case MSG_TEMPERATURE_SENSOR: {
            TemperatureSensor data;
            memcpy(&data, msg.data, sizeof(data));
            doc["value"] = data.celcius;
            doc["online"] = data.online;
            break;
        }
        case MSG_PH_SENSOR: {
            PHSensor data;
            memcpy(&data, msg.data, sizeof(data));
            doc["value"] = data.pH;
            doc["online"] = data.online;
            break;
        }
        case MSG_DO_SENSOR: {
            DissolvedOxygenSensor data;
            memcpy(&data, msg.data, sizeof(data));
            doc["value"] = data.oxygen;
            doc["online"] = data.online;
            break;
        }
        // ... ADD CASES FOR ALL OTHER SENSOR TYPES FROM IPCDataStructs.h HERE ...
        // Example for another sensor:
        case MSG_WEIGHT_SENSOR: {
            WeightSensor data;
            memcpy(&data, msg.data, sizeof(data));
            doc["value"] = data.grams;
            doc["online"] = data.online;
            break;
        }
        default:
            log(LOG_WARNING, false, "MQTT: Unknown sensor type %d for publishing\n", msg.msgId);
            return;
    }

    char payload[256];
    serializeJson(doc, payload, sizeof(payload));

    // 5. Publish the message
    if (mqttClient.publish(fullTopic, payload)) {
        log(LOG_DEBUG, false, "MQTT Published [%s]: %s\n", fullTopic, payload);
    } else {
        log(LOG_WARNING, true, "MQTT publish failed for topic: %s\n", fullTopic);
    }
}
```

##### **6. Modify `src/utils/ipcManager.h`**

```cpp
// src/utils/ipcManager.h
#pragma once

#include "../sys_init.h"

void init_ipcManager(void);
void manageIPC(void);
void registerIpcCallbacks(void); // <-- ADD THIS
```

##### **7. Modify `src/utils/ipcManager.cpp`**

Here we implement the core routing logic from IPC to MQTT.

```cpp
// src/utils/ipcManager.cpp
#include "ipcManager.h"
#include "network/mqttManager.h" // Include for publishing

// Generic handler that forwards any valid sensor message to the MQTT manager
void forwardSensorDataToMqtt(const Message& msg) {
    publishSensorData(msg);
}

void init_ipcManager(void) {
  Serial1.setRX(PIN_SI_RX);
  Serial1.setTX(PIN_SI_TX);
  ipc.begin(115200);
  log(LOG_INFO, false, "Inter-processor communication setup complete\n");
  if (statusLocked) return;
  statusLocked = true;
  status.ipcOK = true; // Assume OK on init, needs heartbeat logic later
  status.updated = true;
  statusLocked = false;
}

void manageIPC(void) {
  // The update() function polls the serial port and fires callbacks automatically
  ipc.update();
}

/**
 * @brief Registers callback functions for all known sensor IPC messages.
 * Each callback will forward the message to the MQTT publishing system.
 */
void registerIpcCallbacks(void) {
    log(LOG_INFO, false, "Registering IPC callbacks for MQTT...\n");

    // Register a single generic handler for all sensor types
    ipc.registerCallback(MSG_TEMPERATURE_SENSOR, forwardSensorDataToMqtt);
    ipc.registerCallback(MSG_PH_SENSOR, forwardSensorDataToMqtt);
    ipc.registerCallback(MSG_DO_SENSOR, forwardSensorDataToMqtt);
    ipc.registerCallback(MSG_OD_SENSOR, forwardSensorDataToMqtt);
    ipc.registerCallback(MSG_GAS_FLOW_SENSOR, forwardSensorDataToMqtt);
    ipc.registerCallback(MSG_PRESSURE_SENSOR, forwardSensorDataToMqtt);
    ipc.registerCallback(MSG_STIRRER_SPEED_SENSOR, forwardSensorDataToMqtt);
    ipc.registerCallback(MSG_WEIGHT_SENSOR, forwardSensorDataToMqtt);
    // Add other sensors here as they are implemented on the I/O controller

    log(LOG_INFO, false, "IPC callbacks registered.\n");
}
```

##### **8. Modify `src/sys_init.cpp`**

Call the new registration function at startup.

```cpp
// src/sys_init.cpp
// ... (includes and object definitions)

void init_core1(void) {
    init_statusManager();
    init_timeManager();
    init_powerManager();
    init_terminalManager();
    init_ipcManager();
    registerIpcCallbacks(); // <-- ADD THIS LINE
    while (!core0setupComplete) delay(100); 
    init_sdManager();   
}

// ... (rest of the file is unchanged)
```

##### **9. Modify `src/utils/terminalManager.cpp` (for testing)**

Add commands to simulate incoming IPC data.

```cpp
// src/utils/terminalManager.cpp
// ... (includes) ...

void manageTerminal(void)
{
    if (serialLocked || !terminalReady) return;
    serialLocked = true;
    if (Serial.available())
    {
        char serialBuffer[128]; // Increased buffer size
        memset(serialBuffer, 0, sizeof(serialBuffer));
        int bytesRead = Serial.readBytesUntil('\n', serialBuffer, sizeof(serialBuffer) - 1);
        serialLocked = false;
        if (bytesRead > 0) {
            serialBuffer[bytesRead] = '\0';
            log(LOG_INFO, true, "Received: %s\n", serialBuffer);
            
            // --- NEW TEST COMMAND LOGIC ---
            char command[20], type[20];
            float value;
            if (sscanf(serialBuffer, "%s %s %f", command, type, &value) == 3 && strcmp(command, "ipc-test") == 0) {
                log(LOG_INFO, true, "Simulating IPC message: type=%s, value=%.2f\n", type, value);
                Message testMsg;
                testMsg.objId = 0; // Test with object ID 0
                testMsg.online = true;

                if (strcmp(type, "temp") == 0) {
                    testMsg.msgId = MSG_TEMPERATURE_SENSOR;
                    TemperatureSensor data = {value, true};
                    testMsg.dataLength = sizeof(data);
                    memcpy(testMsg.data, &data, testMsg.dataLength);
                    publishSensorData(testMsg); // Directly call the handler for testing
                } else if (strcmp(type, "ph") == 0) {
                    testMsg.msgId = MSG_PH_SENSOR;
                    PHSensor data = {value, true};
                    testMsg.dataLength = sizeof(data);
                    memcpy(testMsg.data, &data, testMsg.dataLength);
                    publishSensorData(testMsg);
                } else {
                    log(LOG_WARNING, true, "Unknown ipc-test type: %s\n", type);
                }

            } // --- END OF NEW TEST COMMAND LOGIC ---
            else if (strcmp(serialBuffer, "reboot") == 0) {
                // ... (existing commands) ...
            }
            // ... (rest of the command handling) ...
        }
        // ... (rest of the function) ...
    }
    serialLocked = false;
}
```

---

### **3. Validation and Testing Strategy**

The following steps will validate the entire data pipeline from simulated sensor input to MQTT output.

*   **Testing Steps:**
    1.  Ensure the MQTT broker, port, and credentials are correctly configured in your system (e.g., via the web UI or `network_config.json`).
    2.  Build the project and upload the firmware to the RP2040.
    3.  Open an MQTT client (like MQTT Explorer or `mosquitto_sub`) and connect to your broker.
    4.  Subscribe to the wildcard topic `orcs/sensors/#` to monitor all sensor publications.
    5.  Open the Serial Monitor for the RP2040.
    6.  To simulate a temperature reading from the I/O controller, type the following command into the serial monitor and press Enter:
        ```
        ipc-test temp 37.5
        ```
    7.  To simulate a pH reading, type:
        ```
        ipc-test ph 6.85
        ```

*   **Key Success Metrics:**
    *   **Serial Log Confirmation:** The serial monitor should print logs indicating that the `ipc-test` command was received, a message is being simulated, and that an MQTT publish was executed.
    *   **MQTT Message Arrival:** For the first test command, a new message must appear in your MQTT client on the topic `orcs/sensors/temperature/0`.
    *   **Correct Payload:** The payload of the received MQTT message must be a valid JSON object with the correct structure and values, for example: `{"timestamp":"2025-07-19T10:30:00Z", "value":37.50, "online":true}`. The timestamp will reflect the current time on the device.
    *   **Scalability Check:** Running the `ipc-test ph 6.85` command must result in a new message on a *different* topic (`orcs/sensors/ph/0`) with its corresponding payload, proving the system correctly handles different sensor types.